private Environment . Frame createGlobals ( EventHandler eventHandler , Options options , ConfigFile configFile ) { Environment env = createEnvironment ( eventHandler , Environment . SKYLARK , ImmutableMap . < String , Extension > of ( ) ) ; for ( Class < ? > module : modules ) { logger . log ( Level . INFO , STR_ + module . getName ( ) ) ; Runtime . registerModuleGlobals ( env , module ) ; if ( OptionsAwareModule . class . isAssignableFrom ( module ) ) { ( ( OptionsAwareModule ) getModuleGlobal ( env , module ) ) . setOptions ( options ) ; } if ( LabelsAwareModule . class . isAssignableFrom ( module ) ) { ( ( LabelsAwareModule ) getModuleGlobal ( env , module ) ) . setConfigFile ( configFile ) ; } } env . mutability ( ) . close ( ) ; return env . getGlobals ( ) ; }
private boolean boundsSafe ( int x , int y ) { if ( ( y < NUM_ ) || ( y >= height ) || ( x < NUM_ ) || ( x >= width ) ) { return BOOL_ ; } return BOOL_ ; }
private ResourceResponse patchResourceById ( Context context , Request request , String resourceId , String revision , List < PatchOperation > patchOperations ) throws ResourceException { idRequired ( request . getResourcePath ( ) ) ; noSubObjects ( request . getResourcePath ( ) ) ; ResourceResponse resource = readResource ( context , repoId ( resourceId ) ) ; return patchResource ( context , request , resource , revision , patchOperations ) ; }
private void zoomOut ( ) { chartView . zoomOut ( ) ; zoomControls . setIsZoomInEnabled ( chartView . canZoomIn ( ) ) ; zoomControls . setIsZoomOutEnabled ( chartView . canZoomOut ( ) ) ; }
public CombinedRangeXYPlot ( ValueAxis rangeAxis ) { super ( null , null , rangeAxis , null ) ; this . subplots = new java . util . ArrayList < XYPlot > ( ) ; }
public static void addGhoulArmorTextures ( Item helmet , Item chestplate , Item leggings , Item boots , String res1 , String res2 ) { addGhoulArmorTextures ( helmet , chestplate , leggings , boots , new ResourceLocation ( res1 ) , new ResourceLocation ( res2 ) ) ; }
public NoSuchNameException ( ) { super ( ) ; }
public int optInt ( String key ) { return this . optInt ( key , NUM_ ) ; }
public static void openBugButtonsWindowItem ( Connector connector ) { RaptorWindowItem [ ] items = Raptor . getInstance ( ) . getWindow ( ) . getWindowItems ( BugButtonsWindowItem . class ) ; boolean openNewWindow = BOOL_ ; for ( RaptorWindowItem item : items ) { BugButtonsWindowItem bugButtonsItem = ( BugButtonsWindowItem ) item ; if ( bugButtonsItem . getConnector ( ) == connector ) { Raptor . getInstance ( ) . getWindow ( ) . forceFocus ( item ) ; openNewWindow = BOOL_ ; break ; } } if ( openNewWindow ) { Raptor . getInstance ( ) . getWindow ( ) . addRaptorWindowItem ( new BugButtonsWindowItem ( connector ) ) ; } }
private void writeJavaParameterSpec ( JavaParameterSpec spec , Document document , Element parentElement ) { Element parameter = document . createElement ( STR_ ) ; parentElement . appendChild ( parameter ) ; parameter . setAttribute ( STR_ , spec . getPackageName ( ) ) ; parameter . setAttribute ( STR_ , spec . getClassName ( ) ) ; parameter . setAttribute ( STR_ , spec . getHalfSignature ( ) ) ; parameter . setAttribute ( STR_ , Integer . toString ( spec . getParamIdx ( ) ) ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( NUM_ ) ; newVector . addElement ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; newVector . addElement ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return newVector . elements ( ) ; }
public static boolean isTokenExpired ( String tokenExpiry ) throws CoreTokenException { try { Date expiryDate = DateUtils . stringToDate ( tokenExpiry ) ; long now = currentTimeMillis ( ) ; if ( expiryDate . getTime ( ) <= now ) { return BOOL_ ; } else { return BOOL_ ; } } catch ( ParseException ex ) { String [ ] data = new String [ ] { tokenExpiry } ; throw new CoreTokenException ( NUM_ , data , NUM_ ) ; } }
private void await ( ) { try { boolean nodeRemoved = this . removeConvertedNodes ( root ) ; if ( ! nodeRemoved && root . hasChildren ( ) ) { logger . debug ( STR_ , blockingQueue . size ( ) ) ; this . blockingQueue . take ( ) ; this . blockingQueue . offer ( NUM_ ) ; logger . debug ( STR_ , blockingQueue . size ( ) ) ; } } catch ( InterruptedException e ) { logger . warn ( STR_ ) ; Thread . currentThread ( ) . interrupt ( ) ; } }
public FileFilterUtils ( ) { }
public void addPoint ( PointLayer point ) { Image pointIcon = point . getIcon ( ) ; if ( pointIcon == null ) { point . setIcon ( icon ) ; } if ( ! point . isProjected ( ) ) { Coord c = getProjection ( ) . fromWGS84 ( point ) ; point . setLatitude ( c . getLatitude ( ) ) ; point . setLongitude ( c . getLongitude ( ) ) ; point . setProjected ( BOOL_ ) ; } points . addElement ( point ) ; }
public T caseGreaterOp_ ( GreaterOp_ object ) { return null ; }
public void testStreamVsBytes ( ) throws Exception { FontFactory factory = FontFactory . getInstance ( ) ; byte [ ] data = readToByteArray ( TestFont . TestFontNames . ROBOTO . getFile ( ) ) ; Font byteFont = factory . loadFonts ( data ) [ NUM_ ] ; InputStream is = new FileInputStream ( TestFont . TestFontNames . ROBOTO . getFile ( ) ) ; Font streamFont ; try { streamFont = factory . loadFonts ( is ) [ NUM_ ] ; } finally { is . close ( ) ; } { boolean thrown = BOOL_ ; Glyph byteGlyph = getLastGlyph ( byteFont ) ; try { int byteXMin = byteGlyph . xMin ( ) ; } catch ( IndexOutOfBoundsException e ) { thrown = BOOL_ ; } assertTrue ( STR_ , thrown ) ; } { boolean thrown = BOOL_ ; Glyph streamGlyph = getLastGlyph ( streamFont ) ; try { int streamXMin = streamGlyph . xMin ( ) ; } catch ( IndexOutOfBoundsException e ) { thrown = BOOL_ ; } assertTrue ( STR_ , thrown ) ; } }
public boolean isValidUse ( AnnotatedPrimitiveType type , Tree tree ) { return BOOL_ ; }
@ HLEUnimplemented @ HLEFunction ( nid = NUM_ , version = NUM_ ) public int sceUsbCamPollReadVideoFrameEnd ( ) { if ( jpegBuffer == null || jpegBuffer . isNull ( ) ) { return SceKernelErrors . ERROR_USBCAM_NO_READ_ON_VIDEO_FRAME ; } if ( currentVideoFrameCount <= lastVideoFrameCount ) { if ( log . isDebugEnabled ( ) ) { log . debug ( String . format ( STR_ , currentVideoFrameCount , lastVideoFrameCount ) ) ; } return SceKernelErrors . ERROR_USBCAM_NO_VIDEO_FRAME_AVAILABLE ; } return writeCurrentVideoImage ( jpegBuffer , jpegBufferSize ) ; }
public final static long murmurHash3 ( long x ) { x ^= x > > > NUM_ ; x *= NUM_ ; x ^= x > > > NUM_ ; x *= NUM_ ; x ^= x > > > NUM_ ; return x ; }
@ Override public String toString ( ) { return STR_ + STR_ + sharedSizeBytes + STR_ + STR_ + constSizeBytes + STR_ + STR_ + localSizeBytes + STR_ + STR_ + maxThreadsPerBlock + STR_ + STR_ + numRegs + STR_ + STR_ + ptxVersion + STR_ + STR_ + binaryVersion + STR_ ; }
public boolean isCrippled ( ) { if ( destroyed || jammed || missing || useless || fired ) { return BOOL_ ; } if ( ( type instanceof AmmoWeapon ) || ( type instanceof AmmoBayWeapon ) ) { if ( ( getLinked ( ) == null ) || ( entity . getTotalAmmoOfType ( getLinked ( ) . getType ( ) ) < NUM_ ) ) { return BOOL_ ; } } if ( isDWPMounted && ( getLinkedBy ( ) != null ) ) { return BOOL_ ; } return BOOL_ ; }
public static SimpleScheduleBuilder repeatSecondlyForTotalCount ( int count ) { if ( count < NUM_ ) throw new IllegalArgumentException ( STR_ + count ) ; return simpleSchedule ( ) . withIntervalInSeconds ( NUM_ ) . withRepeatCount ( count - NUM_ ) ; }
protected boolean translateCommand ( StringBuilder buf , String pattern , int index , boolean oldInside ) { char firstChar = pattern . charAt ( index ) ; boolean newInside = oldInside ; if ( firstChar == STR_ || firstChar == STR_ ) { if ( index + NUM_ < pattern . length ( ) ) { newInside = translateCommand ( buf , pattern , index + NUM_ , oldInside ) ; } else { buf . append ( quote ( STR_ + firstChar , oldInside ) ) ; } } else { String command = translate . getProperty ( String . valueOf ( firstChar ) ) ; if ( command == null ) { buf . append ( quote ( STR_ + firstChar , oldInside ) ) ; } else { if ( oldInside ) { buf . append ( STR_ ) ; } buf . append ( command ) ; newInside = BOOL_ ; } } return newInside ; }
public void begin ( String namespace , String name , Attributes attributes ) throws Exception { assert digester . peek ( ) instanceof ManagedBeanBean : STR_ ; if ( digester . getLogger ( ) . isDebugEnabled ( ) ) { digester . getLogger ( ) . debug ( STR_ + digester . getMatch ( ) + STR_ + CLASS_NAME ) ; } Class clazz = digester . getClassLoader ( ) . loadClass ( CLASS_NAME ) ; ManagedPropertyBean mpb = ( ManagedPropertyBean ) clazz . newInstance ( ) ; digester . push ( mpb ) ; }
private static void removeLoopSafepoint ( StructuredGraph graph ) { LoopBeginNode loopBegin = findFirstLoop ( graph ) ; loopBegin . disableSafepoint ( ) ; }
private static long spin ( long ms ) { long start = threadMXBean . getCurrentThreadCpuTime ( ) ; do { long durationMS = ( threadMXBean . getCurrentThreadCpuTime ( ) - start ) / NUM_ ; if ( durationMS >= ms ) { return durationMS ; } } while ( BOOL_ ) ; }
private void zzScanError ( int errorCode ) { String message ; try { message = ZZ_ERROR_MSG [ errorCode ] ; } catch ( ArrayIndexOutOfBoundsException e ) { message = ZZ_ERROR_MSG [ ZZ_UNKNOWN_ERROR ] ; } throw new Error ( message ) ; }
public synchronized void run ( ) { running = BOOL_ ; while ( running ) { try { Socket s = ss . accept ( ) ; acceptedConnections ++ ; if ( acceptedConnections >= acceptLimit ) { running = BOOL_ ; } new Thread ( new Worker ( s ) , STR_ ) . start ( ) ; } catch ( SocketException e ) { log ( e . getMessage ( ) ) ; running = BOOL_ ; } catch ( IOException e ) { log ( e . getMessage ( ) ) ; } } log ( STR_ + this ) ; }
public Enumeration < K > keys ( ) { return new KeyIterator ( ) ; }
protected ActionMap createActionMap ( ) { ActionMap map = super . createActionMap ( ) ; map . put ( STR_ , new EditorActions . SaveAction ( BOOL_ ) ) ; map . put ( STR_ , new EditorActions . SaveAction ( BOOL_ ) ) ; map . put ( STR_ , new EditorActions . NewAction ( ) ) ; map . put ( STR_ , new EditorActions . OpenAction ( ) ) ; map . put ( STR_ , new EditorActions . HistoryAction ( BOOL_ ) ) ; map . put ( STR_ , new EditorActions . HistoryAction ( BOOL_ ) ) ; map . put ( STR_ , mxGraphActions . getSelectVerticesAction ( ) ) ; map . put ( STR_ , mxGraphActions . getSelectEdgesAction ( ) ) ; return map ; }
@ Override public String toString ( ) { Iterator iter = keyMap . entrySet ( ) . iterator ( ) ; StringBuffer buff = new StringBuffer ( STR_ ) ; while ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; buff . append ( STR_ ) . append ( entry . getKey ( ) ) . append ( STR_ ) . append ( entry . getValue ( ) ) ; } return buff . toString ( ) ; }
private void returnData ( Object ret ) { if ( myHost != null ) { myHost . returnData ( ret ) ; } }
private boolean isEmpty ( String value ) { return value . length ( ) == NUM_ ; }
private boolean matchStrings ( String pattern , String str , Map < String , String > uriTemplateVariables ) { AntPathStringMatcher matcher = new AntPathStringMatcher ( pattern , str , uriTemplateVariables ) ; return matcher . matchStrings ( ) ; }
@ Transactional public < VO > VO update ( Class < VO > voType , Object inputParam , User currentUser ) throws Exception { T po = findByIdParam ( inputParam ) ; BeanUtils . copyPropertiesIgnoreNull ( inputParam , po ) ; return updateByPO ( voType , po , currentUser ) ; }
public FromMatchesFilter ( String address ) { if ( address == null ) { throw new IllegalArgumentException ( STR_ ) ; } this . address = address . toLowerCase ( ) ; matchBareJID = STR_ . equals ( StringUtils . parseResource ( address ) ) ; }
public BindOperation processSASLBind ( ByteString rawBindDN , String saslMechanism , ByteString saslCredentials , List < Control > controls ) { BindOperationBasis bindOperation = new BindOperationBasis ( this , nextOperationID ( ) , nextMessageID ( ) , controls , PROTOCOL_VERSION , rawBindDN , saslMechanism , saslCredentials ) ; bindOperation . setInternalOperation ( BOOL_ ) ; bindOperation . run ( ) ; return bindOperation ; }
static void checkParameterIsNotNull ( final String parameterName , final Object parameterValue ) { if ( parameterValue == null ) { throw new IllegalArgumentException ( parameterName + STR_ ) ; } }
public void keyReleased ( KeyEvent e ) { if ( e . getKeyCode ( ) == KeyEvent . VK_ESCAPE ) setText ( m_initialText ) ; }
protected String currentDatabaseCharset ( ) { String charsetName = systemVariables . getVariable ( STR_ ) ; if ( charsetName == null || STR_ . equalsIgnoreCase ( charsetName ) ) { charsetName = systemVariables . getVariable ( SERVER_CHARSET_NAME ) ; } return charsetName ; }
public void terminate ( int delay ) throws RemoteException { System . exit ( NUM_ ) ; }
private static void closeQuietly ( Closeable closeable ) { try { if ( closeable != null ) { closeable . close ( ) ; } } catch ( IOException e ) { Slog . w ( LOG_TAG , e ) ; } }
public void addTokenToFilterChain ( FilterChain filterChain , String key , String value ) { ReplaceTokens replaceToken = new ReplaceTokens ( ) ; ReplaceTokens . Token token = new ReplaceTokens . Token ( ) ; token . setKey ( key ) ; token . setValue ( value ) ; replaceToken . addConfiguredToken ( token ) ; filterChain . addReplaceTokens ( replaceToken ) ; }
public boolean isRelative ( ) { if ( relative == null ) { return BOOL_ ; } else { return relative ; } }
protected HashAttributeSet ( Attribute attribute , Class < ? > interfaceName ) { if ( interfaceName == null ) { throw new NullPointerException ( STR_ ) ; } myInterface = interfaceName ; add ( attribute ) ; }
public static boolean isPolygon ( OMPoly omPoly ) { double [ ] points = omPoly . getLatLonArray ( ) ; int i = points . length ; boolean isPolygon = BOOL_ ; if ( points != null && i > NUM_ ) { isPolygon = points [ NUM_ ] == points [ i - NUM_ ] && points [ NUM_ ] == points [ i - NUM_ ] ; isPolygon = isPolygon && omPoly . isPolygon ( ) ; } return isPolygon ; }
public WrappedByteBuffer slice ( ) { return WrappedByteBuffer . wrap ( _buf . slice ( ) ) ; }
public BinaryTable ( ColumnTable < ? > tabIn ) { @ SuppressWarnings ( STR_ ) ColumnTable < SaveState > tab = ( ColumnTable < SaveState > ) tabIn ; SaveState extra = tab . getExtraState ( ) ; this . columnList = new ArrayList < ColumnDesc > ( ) ; for ( ColumnDesc col : extra . columns ) { ColumnDesc copy = ( ColumnDesc ) col . clone ( ) ; copy . column = null ; this . columnList . add ( copy ) ; } try { this . table = tab . copy ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( STR_ , e ) ; } this . heap = extra . heap . copy ( ) ; this . nRow = tab . getNRows ( ) ; saveExtraState ( ) ; }
public ResultVO errorResp ( Logger logger , Throwable e , ErrorType errorType , String msg ) { LogUtils . traceError ( logger , e , errorType . description ( ) ) ; return new ResultVO ( errorType . name ( ) , OperationStatus . FAILURE , msg ) ; }